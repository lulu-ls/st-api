// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.0
// - protoc             v4.24.4
// source: bag/v1/bag.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationBagListEmoji = "/api.bag.v1.Bag/ListEmoji"
const OperationBagListItem = "/api.bag.v1.Bag/ListItem"
const OperationBagUseItem = "/api.bag.v1.Bag/UseItem"

type BagHTTPServer interface {
	// ListEmoji 表情列表
	ListEmoji(context.Context, *ListEmojiRequest) (*ListEmojiReply, error)
	// ListItem 背包道具列表
	// 获取道具列表
	ListItem(context.Context, *ItemListRequest) (*ItemListReply, error)
	// UseItem 使用道具
	UseItem(context.Context, *UseItemRequest) (*UseItemReply, error)
}

func RegisterBagHTTPServer(s *http.Server, srv BagHTTPServer) {
	r := s.Route("/")
	r.POST("/st-games/v1/bag/item/list", _Bag_ListItem0_HTTP_Handler(srv))
	r.POST("/st-games/v1/bag/emoji/list", _Bag_ListEmoji0_HTTP_Handler(srv))
	r.POST("/st-games/v1/bag/item/use", _Bag_UseItem0_HTTP_Handler(srv))
}

func _Bag_ListItem0_HTTP_Handler(srv BagHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ItemListRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBagListItem)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListItem(ctx, req.(*ItemListRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ItemListReply)
		return ctx.Result(200, reply)
	}
}

func _Bag_ListEmoji0_HTTP_Handler(srv BagHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListEmojiRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBagListEmoji)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListEmoji(ctx, req.(*ListEmojiRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListEmojiReply)
		return ctx.Result(200, reply)
	}
}

func _Bag_UseItem0_HTTP_Handler(srv BagHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UseItemRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBagUseItem)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UseItem(ctx, req.(*UseItemRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UseItemReply)
		return ctx.Result(200, reply)
	}
}

type BagHTTPClient interface {
	ListEmoji(ctx context.Context, req *ListEmojiRequest, opts ...http.CallOption) (rsp *ListEmojiReply, err error)
	ListItem(ctx context.Context, req *ItemListRequest, opts ...http.CallOption) (rsp *ItemListReply, err error)
	UseItem(ctx context.Context, req *UseItemRequest, opts ...http.CallOption) (rsp *UseItemReply, err error)
}

type BagHTTPClientImpl struct {
	cc *http.Client
}

func NewBagHTTPClient(client *http.Client) BagHTTPClient {
	return &BagHTTPClientImpl{client}
}

func (c *BagHTTPClientImpl) ListEmoji(ctx context.Context, in *ListEmojiRequest, opts ...http.CallOption) (*ListEmojiReply, error) {
	var out ListEmojiReply
	pattern := "/st-games/v1/bag/emoji/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBagListEmoji))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BagHTTPClientImpl) ListItem(ctx context.Context, in *ItemListRequest, opts ...http.CallOption) (*ItemListReply, error) {
	var out ItemListReply
	pattern := "/st-games/v1/bag/item/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBagListItem))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BagHTTPClientImpl) UseItem(ctx context.Context, in *UseItemRequest, opts ...http.CallOption) (*UseItemReply, error) {
	var out UseItemReply
	pattern := "/st-games/v1/bag/item/use"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBagUseItem))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
